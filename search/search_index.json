{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"dependence","text":"<p>Dependence provides a Command Line Interface and library for aligning a python projects' declared dependencies with the package versions installed in the environment in which <code>dependence</code> is executed, and for \"freezing\" recursively resolved package dependencies (like <code>pip freeze</code>, but for a package, instead of the entire environment).</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install <code>dependence</code> with pip:</p> <pre><code>pip3 install dependence\n</code></pre>"},{"location":"#example-usage","title":"Example Usage","text":""},{"location":"#listing-dependencies","title":"Listing Dependencies","text":"<p>The <code>dependence freeze</code> command, and the <code>dependence.freeze.freeze</code> function, print all requirements for one or more specified python project, requirements.txt, pyproject.toml, setup.cfg, or tox.ini files. The output format matches that of <code>pip freeze</code>, but only lists dependencies of indicated packages and/or editable project locations.</p> <p>You may refer to the <code>dependence freeze</code> CLI reference and/or <code>dependence.freeze</code> API reference for details concerning this command/module, related options, and more complex use case examples.</p> <p>We'll use this project, <code>dependence</code>, as a simple example. To start with, let's see what the currently installed dependencies for this package look like at the time of writing:</p> <pre><code>$ dependence freeze .\npackaging==24.1\npip==24.3.0\nsetuptools==75.1.0\ntomli==2.1.0\ntomli_w==1.0.0\n</code></pre> <p>...now let's save this output for later comparison purposes:</p> <pre><code>dependence freeze . &gt; requirements_before.txt\n</code></pre> <p>Now, we'll upgrade our dependencies and see what they look like after:</p> <pre><code>$ pip install -q --upgrade --upgrade-strategy eager . &amp;&amp; dependence freeze .\npackaging==24.2\npip==24.3.1\nsetuptools==75.3.0\ntomli==2.2.1\ntomli_w==1.0.0\n</code></pre> <p>...next let's dump them to a file and compare them with our previous dependencies:</p> <pre><code>$ dependence freeze . &gt; dependence_after.txt\n$ diff dependence_before.txt dependence_after.txt\n1,5c1,5\n&lt; packaging==24.1\n&lt; pip==24.3.0\n&lt; setuptools==75.1.0\n&lt; tomli==2.1.0\n&lt; tomli_w==1.0.0\n---\n&gt; packaging==24.2\n&gt; pip==24.3.1\n&gt; setuptools==75.3.0\n&gt; tomli==2.2.1\n&gt; tomli_w==1.0.1\n</code></pre> <p>As you can see above, all of our dependencies have been upgraded.</p>"},{"location":"#updating-requirement-specifiers","title":"Updating Requirement Specifiers","text":"<p>To start with, let's take a look at our pyproject.toml file:</p> <pre><code>[project]\nname = \"dependence\"\nversion = \"1.0.0\"\ndependencies = [\n    \"packaging&gt;23\",\n    \"pip\",\n    \"setuptools&gt;63\",\n    \"tomli-w~=1.0\",\n    \"tomli~=2.1\",\n]\n</code></pre> <p>Now that we've upgraded our dependencies, we want to update our pyproject.toml file to align with our upgraded dependencies. This is desirable to ensure that <code>dependence</code> isn't installed alongside a version of one of its dependencies preceding functionality utilized by <code>dependence</code>.</p> <pre><code>dependence update pyproject.toml\n</code></pre> <p>Afterwards, our pyproject.toml file looks like this:</p> <pre><code>[project]\nname = \"dependence\"\nversion = \"1.0.0\"\ndependencies = [\n    \"packaging&gt;23\",\n    \"pip\",\n    \"setuptools&gt;63\",\n    \"tomli-w~=1.0\",\n    \"tomli~=2.2\",\n]\n</code></pre> <p>Here's the diff:</p> <pre><code>$ diff pyproject_before.toml pyproject_after.toml\n9c9\n&lt;     \"tomli~=2.1\",\n---\n&gt;     \"tomli~=2.2\",\n</code></pre> <p>As you can see, only the version specifier for tomli changed. We know that every dependency was upgraded, wo why was only the <code>tomli</code> version specifier updated? By design. Here are the rules <code>dependence update</code> adheres to:</p> <ul> <li>We only update requirements versions when they have inclusive specifiers.     For example, <code>~=</code>, <code>&gt;=</code>, and <code>&lt;=</code> are inclusive, whereas <code>!=</code>, <code>&gt;</code>, and     <code>&lt;</code> are exclusive. For this reason, nothing changed for     \"packaging\" and \"setuptools\" in our above example.</li> <li>We always retain the existing level of specificity. If your version     specifier is <code>~=1.2</code>, and the new version is <code>1.5.6</code>, we're going to     update your specifier to <code>~=1.5</code>. If your requirement has a minor version     level of specificity, and only a patch version upgrade is performed,     nothing will change in your project dependency specifier. This is why     you do not see any change in our above pyproject.toml file for the     <code>tomli-w</code> dependency\u2014both new and old share the same minor version.</li> <li>If your requirement is unversioned, we don't touch it, of course. This is     why you didn't see any change for \"pip\".</li> </ul> <p>You may refer to the <code>dependence update</code> CLI reference and/or <code>dependence.update</code> API reference for details concerning this command/module, related options, and more complex use cases/examples.</p>"},{"location":"cli/","title":"Command Line Interface","text":"<pre><code>$ dependence -h\nUsage:\n  dependence &lt;command&gt; [options]\n\nCommands:\n  update                      Update requirement versions in the specified\n                              files to align with currently installed versions\n                              of each distribution\n  freeze                      Print dependencies inferred from an installed\n                              distribution or project, in a similar format\n                              to the output of `pip freeze`.\n</code></pre>"},{"location":"cli/#dependence-update","title":"dependence update","text":"<p>This command will update version specifiers for all package requirements in your setup.cfg, pyproject.toml, tox.ini, or requirements.txt files to match currently installed versions of each distribution (matching the existing granularity, and only for inclusive specifiers\u2014so where the comparator is \"~=\", \"==\", \"&gt;=\", or \"&lt;=\", but not where the comparator is \"&gt;\", \"&lt;\", or \"!=\").</p> <pre><code>$ dependence update -h\nusage: dependence update [-h] [-i IGNORE] [-aen ALL_EXTRA_NAME]\n                         [--include-pointer INCLUDE_POINTER]\n                         [--exclude-pointer EXCLUDE_POINTER]\n                         path [path ...]\n\nUpdate requirement versions in the specified files to align with currently\ninstalled versions of each distribution.\n\npositional arguments:\n  path                  One or more local paths to a *.toml, setup.cfg,\n                        and/or requirements.txt file\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -i IGNORE, --ignore IGNORE\n                        A comma-separated list of distributions to ignore\n                        (leave any requirements pertaining to the package\n                        as-is)\n  -aen ALL_EXTRA_NAME, --all-extra-name ALL_EXTRA_NAME\n                        If provided, an extra which consolidates the\n                        requirements for all other extras will be\n                        added/updated to pyproject.toml or setup.cfg (this\n                        argument is ignored for requirements.txt files and\n                        other TOML files)\n  --include-pointer INCLUDE_POINTER\n                        One or more JSON pointers of elements to *include*\n                        (applies to TOML files only)\n  --exclude-pointer EXCLUDE_POINTER\n                        One or more JSON pointers of elements to *exclude*\n                        (applies to TOML files only)\n</code></pre> <p>Example:</p> <pre><code>dependence update -aen all setup.cfg pyproject.toml tox.ini\n</code></pre>"},{"location":"cli/#dependence-freeze","title":"dependence freeze","text":"<pre><code>$ dependence freeze -h\nusage: dependence freeze [-h] [-e EXCLUDE] [-er EXCLUDE_RECURSIVE]\n                         [-nv NO_VERSION] [-do] [--reverse] [-d DEPTH]\n                         [--include-pointer INCLUDE_POINTER]\n                         [--exclude-pointer EXCLUDE_POINTER]\n                         requirement [requirement ...]\n\nThis command prints dependencies inferred from an installed distribution\nor project, in a similar format to the output of `pip freeze`, except that\nall generated requirements are specified in the format \"distribution-\nname==0.0.0\" (including for editable installations). Using this command\ninstead of `pip freeze` to generate requirement files ensures that you\ndon't bloat your requirements files with superfluous distributions.\n\npositional arguments:\n  requirement           One or more requirement specifiers (for example:\n                        \"requirement-name\", \"requirement-\n                        name[extra-a,extra-b]\", \".[extra-a, extra-b]\" or\n                        \"../other-editable-package-directory[extra-a,\n                        extra-b]) and/or paths to a setup.py, setup.cfg,\n                        pyproject.toml, tox.ini or requirements.txt file\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -e EXCLUDE, --exclude EXCLUDE\n                        A distribution (or comma-separated list of\n                        distributions) to exclude from the output\n  -er EXCLUDE_RECURSIVE, --exclude-recursive EXCLUDE_RECURSIVE\n                        A distribution (or comma-separated list of\n                        distributions) to exclude from the output. Unlike\n                        -e / --exclude, this argument also precludes\n                        recursive requirement discovery for the specified\n                        packages, thereby excluding all of the excluded\n                        package's requirements which are not required by\n                        another (non-excluded) distribution.\n  -nv NO_VERSION, --no-version NO_VERSION\n                        Don't include versions (only output distribution\n                        names) for packages matching this/these glob\n                        pattern(s) (note: the value must be single-quoted\n                        if it contains wildcards)\n  -do, --dependency-order\n                        Sort requirements so that dependents precede\n                        dependencies\n  --reverse             Print requirements in reverse order\n  -d DEPTH, --depth DEPTH\n                        Depth of recursive requirement discovery\n  --include-pointer INCLUDE_POINTER\n                        One or more JSON pointers of elements to *include*\n                        (applies to TOML files only)\n  --exclude-pointer EXCLUDE_POINTER\n                        One or more JSON pointers of elements to *exclude*\n                        (applies to TOML files only)\n</code></pre>"},{"location":"contributing/","title":"Contributing to dependence","text":""},{"location":"contributing/#for-enorganic-contributors-and-code-owners","title":"For Enorganic Contributors and Code Owners","text":"<ol> <li> <p>Clone and Install</p> <p>To install this project for development of this library, clone this repository (replacing \"~/Code\", below, with the directory under which you want your project to reside), then run <code>make</code>:</p> <pre><code>cd ~/Code &amp;&amp; \\\ngit clone\\\nhttps://github.com/enorganic/dependence.git dependence &amp;&amp; \\\ncd dependence &amp;&amp; \\\nmake\n</code></pre> </li> <li> <p>Create a new branch for your changes (replacing \"descriptive-branch-name\"     with a descriptive branch name, and replacing feature with bugfix     if the branch addresses a bug):</p> <pre><code>git branch feature/descriptive-branch-name\n</code></pre> </li> <li> <p>Make some changes.</p> </li> <li> <p>Format and lint your code:</p> <pre><code>make format\n</code></pre> </li> <li> <p>Test your changes:</p> <pre><code>make test\n</code></pre> </li> <li> <p>Push your changes and create a pull request.</p> </li> </ol>"},{"location":"contributing/#for-everyone-else","title":"For Everyone Else","text":"<p>If you are not a contributor on this project, you can still create pull requests, however you will need to fork this project, push changes to your fork, and create a pull request from your forked repository.</p>"},{"location":"api/freeze/","title":"freeze","text":""},{"location":"api/freeze/#dependence.freeze","title":"dependence.freeze","text":""},{"location":"api/freeze/#dependence.freeze._iter_sort_dependents_last","title":"_iter_sort_dependents_last","text":"<pre><code>_iter_sort_dependents_last(\n    requirements: collections.abc.Iterable[str],\n) -&gt; collections.abc.Iterable[str]\n</code></pre> <p>Sort requirements such that dependents are first and dependencies are last.</p> Source code in <code>src/dependence/freeze.py</code> <pre><code>def _iter_sort_dependents_last(requirements: Iterable[str]) -&gt; Iterable[str]:\n    \"\"\"\n    Sort requirements such that dependents are first and dependencies are last.\n    \"\"\"\n    requirements = list(requirements)\n    distribution_name: str\n    distribution_requirement: dict[str, str] = {\n        get_requirement_string_distribution_name(requirement): requirement\n        for requirement in requirements\n    }\n    dependent_dependencies: dict[str, MutableSet[str]] = {\n        distribution_name: get_required_distribution_names(requirement)\n        for distribution_name, requirement in distribution_requirement.items()\n    }\n    while dependent_dependencies:\n        dependent: str\n        dependencies: MutableSet[str]\n        item: tuple[str, MutableSet[str]]\n        for dependent, dependencies in sorted(  # noqa: C414\n            tuple(dependent_dependencies.items()),\n            key=lambda item: item[0].lower(),\n        ):\n\n            def is_non_circular_requirement(\n                dependency: str,\n                dependent: str,\n            ) -&gt; bool:\n                \"\"\"\n                Return `True` if the dependency is still among the unaccounted\n                for requirements, and is not a circular reference\n                \"\"\"\n                return (dependency in dependent_dependencies) and (\n                    # Exclude interdependent distributions\n                    # (circular references)\n                    dependent not in dependent_dependencies[dependency]\n                )\n\n            if (not dependencies) or not any(\n                map(\n                    partial(is_non_circular_requirement, dependent=dependent),\n                    dependencies,\n                )\n            ):\n                yield distribution_requirement.pop(dependent)\n                del dependent_dependencies[dependent]\n</code></pre>"},{"location":"api/freeze/#dependence.freeze.get_frozen_requirements","title":"get_frozen_requirements","text":"<pre><code>get_frozen_requirements(\n    requirements: collections.abc.Iterable[str] = (),\n    *,\n    exclude: collections.abc.Iterable[str] = (),\n    exclude_recursive: collections.abc.Iterable[str] = (),\n    no_version: collections.abc.Iterable[str] = (),\n    dependency_order: bool = False,\n    reverse: bool = False,\n    depth: int | None = None,\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = ()\n) -&gt; tuple[str, ...]\n</code></pre> <p>Get the (frozen) requirements for one or more specified distributions or configuration files.</p> <p>Parameters:</p> <ul> <li> <code>requirements</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more requirement specifiers (for example: \"requirement-name[extra-a,extra-b]\" or \".[extra-a, extra-b]) and/or paths to a setup.cfg, pyproject.toml, tox.ini or requirements.txt file</p> </li> <li> <code>exclude</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more distributions to exclude/ignore</p> </li> <li> <code>exclude_recursive</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more distributions to exclude/ignore. Note: Excluding a distribution here excludes all requirements which would be identified through recursion.</p> </li> <li> <code>no_version</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>Exclude version numbers from the output (only return distribution names)</p> </li> <li> <code>dependency_order</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort requirements so that dependents precede dependencies</p> </li> <li> <code>depth</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Depth of recursive requirement discovery</p> </li> <li> <code>include_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>A tuple of JSON pointers indicating elements to include (defaults to all elements). Only applies to TOML files.</p> </li> <li> <code>exclude_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>A tuple of JSON pointers indicating elements to exclude (defaults to no exclusions). Only applies to TOML files.</p> </li> </ul> Source code in <code>src/dependence/freeze.py</code> <pre><code>def get_frozen_requirements(\n    requirements: Iterable[str] = (),\n    *,\n    exclude: Iterable[str] = (),\n    exclude_recursive: Iterable[str] = (),\n    no_version: Iterable[str] = (),\n    dependency_order: bool = False,\n    reverse: bool = False,\n    depth: int | None = None,\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = (),\n) -&gt; tuple[str, ...]:\n    \"\"\"\n    Get the (frozen) requirements for one or more specified distributions or\n    configuration files.\n\n    Parameters:\n        requirements: One or more requirement specifiers (for example:\n            \"requirement-name[extra-a,extra-b]\" or \".[extra-a, extra-b]) and/or\n            paths to a setup.cfg, pyproject.toml, tox.ini or requirements.txt\n            file\n        exclude: One or more distributions to exclude/ignore\n        exclude_recursive: One or more distributions to exclude/ignore.\n            Note: Excluding a distribution here excludes all requirements which\n            would be identified through recursion.\n        no_version: Exclude version numbers from the output\n            (only return distribution names)\n        dependency_order: Sort requirements so that dependents\n            precede dependencies\n        depth: Depth of recursive requirement discovery\n        include_pointers: A tuple of JSON pointers indicating elements to\n            include (defaults to all elements). Only applies to TOML files.\n        exclude_pointers: A tuple of JSON pointers indicating elements to\n            exclude (defaults to no exclusions). Only applies to TOML files.\n    \"\"\"\n    # Separate requirement strings from requirement files\n    if isinstance(requirements, str):\n        requirements = {requirements}\n    else:\n        requirements = set(requirements)\n    if isinstance(no_version, str):\n        no_version = (no_version,)\n    elif not isinstance(no_version, tuple):\n        no_version = tuple(no_version)\n    requirement_files: MutableSet[str] = set(\n        filter(is_configuration_file, requirements)\n    )\n    requirement_strings: MutableSet[str] = cast(\n        MutableSet[str], requirements - requirement_files\n    )\n    frozen_requirements: Iterable[str] = iter_distinct(\n        chain(\n            requirement_strings,\n            *map(\n                partial(\n                    iter_configuration_file_requirement_strings,\n                    include_pointers=include_pointers,\n                    exclude_pointers=exclude_pointers,\n                ),\n                requirement_files,\n            ),\n        )\n    )\n    if depth is not None:\n        depth -= 1\n    if (depth is None) or depth &gt;= 0:\n        frozen_requirements = _iter_frozen_requirements(\n            frozen_requirements,\n            exclude=set(\n                chain(\n                    # Exclude requirement strings which are *not*\n                    # distribution names (such as editable package paths),\n                    # as in these cases we are typically looking for this\n                    # package's dependencies\n                    (\n                        set(\n                            map(\n                                get_requirement_string_distribution_name,\n                                requirement_strings,\n                            )\n                        )\n                        - set(map(normalize_name, requirement_strings))\n                    ),\n                    map(normalize_name, exclude),\n                )\n            ),\n            exclude_recursive=set(map(normalize_name, exclude_recursive)),\n            no_version=no_version,\n            depth=depth,\n        )\n    if dependency_order:\n        frozen_requirements = tuple(\n            _iter_sort_dependents_last(frozen_requirements)\n        )\n        if not reverse:\n            frozen_requirements = tuple(reversed(frozen_requirements))\n    else:\n        name: str\n        frozen_requirements = tuple(\n            sorted(\n                frozen_requirements,\n                key=lambda name: name.lower(),\n                reverse=reverse,\n            )\n        )\n    return frozen_requirements\n</code></pre>"},{"location":"api/freeze/#dependence.freeze.freeze","title":"freeze","text":"<pre><code>freeze(\n    requirements: collections.abc.Iterable[str] = (),\n    *,\n    exclude: collections.abc.Iterable[str] = (),\n    exclude_recursive: collections.abc.Iterable[str] = (),\n    no_version: collections.abc.Iterable[str] = (),\n    dependency_order: bool = False,\n    reverse: bool = False,\n    depth: int | None = None,\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = ()\n) -&gt; None\n</code></pre> <p>Print the (frozen) requirements for one or more specified requirements or configuration files.</p> <p>Parameters:</p> <ul> <li> <code>requirements</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more requirement specifiers (for example: \"requirement-name[extra-a,extra-b]\" or \".[extra-a, extra-b]) and/or paths to a setup.py, setup.cfg, pyproject.toml, tox.ini or requirements.txt file</p> </li> <li> <code>exclude</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more distributions to exclude/ignore</p> </li> <li> <code>exclude_recursive</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more distributions to exclude/ignore. Note: Excluding a distribution here halts recursive discovery of requirements.</p> </li> <li> <code>no_version</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>Exclude version numbers from the output (only print distribution names) for package names matching any of these patterns</p> </li> <li> <code>dependency_order</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort requirements so that dependents precede dependencies</p> </li> <li> <code>depth</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Depth of recursive requirement discovery</p> </li> <li> <code>include_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>If this not empty, only these TOML tables will inspected (for pyproject.toml files)</p> </li> <li> <code>exclude_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>If not empty, these TOML tables will not be inspected (for pyproject.toml files)</p> </li> </ul> Source code in <code>src/dependence/freeze.py</code> <pre><code>def freeze(\n    requirements: Iterable[str] = (),\n    *,\n    exclude: Iterable[str] = (),\n    exclude_recursive: Iterable[str] = (),\n    no_version: Iterable[str] = (),\n    dependency_order: bool = False,\n    reverse: bool = False,\n    depth: int | None = None,\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = (),\n) -&gt; None:\n    \"\"\"\n    Print the (frozen) requirements for one or more specified requirements or\n    configuration files.\n\n    Parameters:\n        requirements: One or more requirement specifiers (for example:\n            \"requirement-name[extra-a,extra-b]\" or \".[extra-a, extra-b]) and/or\n            paths to a setup.py, setup.cfg, pyproject.toml, tox.ini or\n            requirements.txt file\n        exclude: One or more distributions to exclude/ignore\n        exclude_recursive: One or more distributions to exclude/ignore.\n            Note: Excluding a distribution here halts recursive\n            discovery of requirements.\n        no_version: Exclude version numbers from the output\n            (only print distribution names) for package names matching any of\n            these patterns\n        dependency_order: Sort requirements so that dependents\n            precede dependencies\n        depth: Depth of recursive requirement discovery\n        include_pointers: If this not empty, *only* these TOML tables will\n            inspected (for pyproject.toml files)\n        exclude_pointers: If not empty, these TOML tables will *not* be\n            inspected (for pyproject.toml files)\n    \"\"\"\n    print(  # noqa: T201\n        \"\\n\".join(\n            get_frozen_requirements(\n                requirements=requirements,\n                exclude=exclude,\n                exclude_recursive=exclude_recursive,\n                no_version=no_version,\n                dependency_order=dependency_order,\n                reverse=reverse,\n                depth=depth,\n                include_pointers=include_pointers,\n                exclude_pointers=exclude_pointers,\n            )\n        )\n    )\n</code></pre>"},{"location":"api/update/","title":"update","text":""},{"location":"api/update/#dependence.update","title":"dependence.update","text":""},{"location":"api/update/#dependence.update._Version","title":"_Version  <code>dataclass</code>","text":"<p>Instances of this class can be be passed as <code>self</code> in a call to <code>packaging.version.Version.__str__</code>, and thereby can facilitate operations to mimic mutability for the aforementioned class.</p> Source code in <code>src/dependence/update.py</code> <pre><code>@dataclass\nclass _Version:\n    \"\"\"\n    Instances of this class can be be passed as `self` in a call\n    to `packaging.version.Version.__str__`, and thereby can facilitate\n    operations to mimic mutability for the aforementioned class.\n    \"\"\"\n\n    epoch: int\n    release: tuple[int, ...]\n    pre: Any\n    post: Any\n    dev: Any\n    local: Any\n</code></pre>"},{"location":"api/update/#dependence.update._update_requirement_specifiers","title":"_update_requirement_specifiers","text":"<pre><code>_update_requirement_specifiers(\n    requirement: packaging.requirements.Requirement,\n    installed_version_string: str,\n) -&gt; None\n</code></pre> <p>This function updates specifier version numbers for a requirement to match the installed version of the package</p> Source code in <code>src/dependence/update.py</code> <pre><code>def _update_requirement_specifiers(\n    requirement: Requirement, installed_version_string: str\n) -&gt; None:\n    \"\"\"\n    This function updates specifier version numbers for a requirement\n    to match the installed version of the package\n    \"\"\"\n    installed_version: Version = parse_version(installed_version_string)\n    specifier: Specifier\n    updated_specifier_strings: list[str] = []\n    for specifier in requirement.specifier:  # type: ignore\n        # Only update requirement to match our installed version\n        # if the requirement is *inclusive*\n        if (\"=\" in specifier.operator) and (\"!\" not in specifier.operator):\n            specifier_version: Version = parse_version(specifier.version)\n            if installed_version.release is None:\n                raise ValueError(installed_version)\n            if specifier_version.release is None:\n                updated_specifier_strings.append(f\"{specifier.operator}\")\n            else:\n                greater_or_equal_specificity: bool = len(\n                    specifier_version.release\n                ) &gt;= len(installed_version.release)\n                specifier_version_data: _Version = _Version(\n                    epoch=installed_version.epoch,\n                    # Truncate the updated version requirement at the same\n                    # level of specificity as the old\n                    release=installed_version.release[\n                        : len(specifier_version.release)\n                    ],\n                    pre=(\n                        installed_version.pre\n                        if greater_or_equal_specificity\n                        else None\n                    ),\n                    post=(\n                        installed_version.post\n                        if greater_or_equal_specificity\n                        else None\n                    ),\n                    dev=(\n                        installed_version.dev\n                        if greater_or_equal_specificity\n                        else None\n                    ),\n                    local=(\n                        installed_version.local\n                        if greater_or_equal_specificity\n                        else None\n                    ),\n                )\n                version_string: str = Version.__str__(\n                    specifier_version_data  # type: ignore\n                )\n                updated_specifier_strings.append(\n                    f\"{specifier.operator}{version_string}\"\n                )\n        else:\n            updated_specifier_strings.append(str(specifier))\n    requirement.specifier = SpecifierSet(\",\".join(updated_specifier_strings))\n</code></pre>"},{"location":"api/update/#dependence.update._get_updated_requirement_string","title":"_get_updated_requirement_string","text":"<pre><code>_get_updated_requirement_string(\n    requirement_string: str, ignore: set[str]\n) -&gt; str\n</code></pre> <p>This function updates version numbers in a requirement string to match those installed in the current environment</p> Source code in <code>src/dependence/update.py</code> <pre><code>def _get_updated_requirement_string(\n    requirement_string: str, ignore: set[str]\n) -&gt; str:\n    \"\"\"\n    This function updates version numbers in a requirement string to match\n    those installed in the current environment\n    \"\"\"\n    # Skip empty requirement strings\n    if not is_requirement_string(requirement_string):\n        return requirement_string\n    requirement: Requirement = Requirement(requirement_string)\n    name: str = normalize_name(requirement.name)\n    if name in ignore:\n        return requirement_string\n    try:\n        distribution: Distribution = get_installed_distributions()[name]\n        _update_requirement_specifiers(requirement, distribution.version)\n    except KeyError:\n        # If the requirement isn't installed, we can't update the version\n        pass\n    return str(requirement)\n</code></pre>"},{"location":"api/update/#dependence.update._get_updated_requirements_txt","title":"_get_updated_requirements_txt","text":"<pre><code>_get_updated_requirements_txt(\n    data: str, ignore: collections.abc.Iterable[str] = ()\n) -&gt; str\n</code></pre> <p>Return the contents of a requirements.txt file, updated to reflect the currently installed project versions, excluding those specified in <code>ignore</code>.</p> <p>Parameters:</p> <ul> <li>data (str): The contents of a requirements.txt file</li> <li>ignore ([str]): One or more project names to leave as-is</li> </ul> Source code in <code>src/dependence/update.py</code> <pre><code>def _get_updated_requirements_txt(\n    data: str, ignore: Iterable[str] = ()\n) -&gt; str:\n    \"\"\"\n    Return the contents of a *requirements.txt* file, updated to reflect the\n    currently installed project versions, excluding those specified in\n    `ignore`.\n\n    Parameters:\n\n    - data (str): The contents of a *requirements.txt* file\n    - ignore ([str]): One or more project names to leave as-is\n    \"\"\"\n    ignore_set: set[str] = _normalize_ignore_argument(ignore)\n\n    def get_updated_requirement_string(requirement: str) -&gt; str:\n        return _get_updated_requirement_string(requirement, ignore=ignore_set)\n\n    return \"\\n\".join(map(get_updated_requirement_string, data.split(\"\\n\")))\n</code></pre>"},{"location":"api/update/#dependence.update._get_updated_setup_cfg","title":"_get_updated_setup_cfg","text":"<pre><code>_get_updated_setup_cfg(\n    data: str,\n    ignore: collections.abc.Iterable[str] = (),\n    all_extra_name: str = \"\",\n) -&gt; str\n</code></pre> <p>Return the contents of a setup.cfg file, updated to reflect the currently installed project versions, excluding those specified in <code>ignore</code>.</p> <p>Parameters:</p> <ul> <li>data (str): The contents of a setup.cfg file</li> <li>ignore ([str]): One or more project names to leave as-is</li> <li>all_extra_name (str): An (optional) extra name which will   consolidate requirements from all other extras</li> </ul> Source code in <code>src/dependence/update.py</code> <pre><code>def _get_updated_setup_cfg(\n    data: str, ignore: Iterable[str] = (), all_extra_name: str = \"\"\n) -&gt; str:\n    \"\"\"\n    Return the contents of a *setup.cfg* file, updated to reflect the\n    currently installed project versions, excluding those specified in\n    `ignore`.\n\n    Parameters:\n\n    - data (str): The contents of a *setup.cfg* file\n    - ignore ([str]): One or more project names to leave as-is\n    - all_extra_name (str): An (optional) extra name which will\n      consolidate requirements from all other extras\n    \"\"\"\n    ignore_set: set[str] = _normalize_ignore_argument(ignore)\n\n    def get_updated_requirement_string(requirement: str) -&gt; str:\n        return _get_updated_requirement_string(requirement, ignore=ignore_set)\n\n    # Parse\n    parser: ConfigParser = ConfigParser()\n    parser.read_string(data)\n    # Update\n    if (\"options\" in parser) and (\"install_requires\" in parser[\"options\"]):\n        parser[\"options\"][\"install_requires\"] = \"\\n\".join(\n            map(  # type: ignore\n                get_updated_requirement_string,\n                parser[\"options\"][\"install_requires\"].split(\"\\n\"),\n            )\n        )\n    if \"options.extras_require\" in parser:\n        extras_require: SectionProxy = parser[\"options.extras_require\"]\n        all_extra_requirements: list[str] = []\n        extra_name: str\n        extra_requirements_string: str\n        extra_requirements: list[str]\n        for extra_name, extra_requirements_string in extras_require.items():\n            if extra_name != all_extra_name:\n                extra_requirements = list(\n                    map(\n                        get_updated_requirement_string,\n                        extra_requirements_string.split(\"\\n\"),\n                    )\n                )\n                if all_extra_name:\n                    all_extra_requirements += extra_requirements\n                extras_require[extra_name] = \"\\n\".join(extra_requirements)\n        # If a name was specified for an all-encompasing extra,\n        # we de-duplicate and update or create that extra\n        if all_extra_name:\n            # We pre-pend an empty requirement string in order to]\n            # force new-line creation at the beginning of the extra\n            extras_require[all_extra_name] = \"\\n\".join(\n                iter_distinct([\"\", *all_extra_requirements])\n            )\n    # Return as a string\n    setup_cfg: str\n    setup_cfg_io: IO[str]\n    with StringIO() as setup_cfg_io:\n        parser.write(setup_cfg_io)\n        setup_cfg_io.seek(0)\n        setup_cfg = re.sub(r\"[ ]+(\\n|$)\", r\"\\1\", setup_cfg_io.read()).strip()\n        return f\"{setup_cfg}\\n\"\n</code></pre>"},{"location":"api/update/#dependence.update._get_updated_tox_ini","title":"_get_updated_tox_ini","text":"<pre><code>_get_updated_tox_ini(\n    data: str, ignore: collections.abc.Iterable[str] = ()\n) -&gt; str\n</code></pre> <p>Return the contents of a tox.ini file, updated to reflect the currently installed project versions, excluding those specified in <code>ignore</code>.</p> <p>Parameters:</p> <ul> <li>data (str): The contents of a tox.ini file</li> <li>ignore ([str]): One or more project names to leave as-is</li> </ul> Source code in <code>src/dependence/update.py</code> <pre><code>def _get_updated_tox_ini(data: str, ignore: Iterable[str] = ()) -&gt; str:\n    \"\"\"\n    Return the contents of a **tox.ini** file, updated to reflect the\n    currently installed project versions, excluding those specified in\n    `ignore`.\n\n    Parameters:\n\n    - data (str): The contents of a **tox.ini** file\n    - ignore ([str]): One or more project names to leave as-is\n    \"\"\"\n    ignore_set: set[str] = _normalize_ignore_argument(ignore)\n\n    def get_updated_requirement_string(requirement: str) -&gt; str:\n        prefix: str | None = None\n        if \":\" in requirement:\n            prefix, requirement = requirement.split(\":\", maxsplit=1)\n        requirement = _get_updated_requirement_string(\n            requirement, ignore=ignore_set\n        )\n        if prefix is not None:\n            requirement = f\"{prefix}: {requirement.lstrip()}\"\n        return requirement\n\n    # Parse\n    parser: ConfigParser = ConfigParser()\n    parser.read_string(data)\n\n    def update_section_options(section_name: str, option_name: str) -&gt; None:\n        if parser.has_option(section_name, option_name):\n            parser.set(\n                section_name,\n                option_name,\n                \"\\n\".join(\n                    map(\n                        get_updated_requirement_string,\n                        parser.get(section_name, option_name).split(\"\\n\"),\n                    )\n                ),\n            )\n\n    def update_section(section_name: str) -&gt; None:\n        update_section_options(section_name, \"deps\")\n        if section_name == \"tox\":\n            update_section_options(section_name, \"requires\")\n\n    # Update\n    list(map(update_section, parser.sections()))\n    # Return as a string\n    tox_ini: str\n    tox_ini_io: IO[str]\n    with StringIO() as tox_ini_io:\n        parser.write(tox_ini_io)\n        tox_ini_io.seek(0)\n        tox_ini = re.sub(r\"[ ]+(\\n|$)\", r\"\\1\", tox_ini_io.read()).strip()\n        return f\"{tox_ini}\\n\"\n</code></pre>"},{"location":"api/update/#dependence.update._get_updated_pyproject_toml","title":"_get_updated_pyproject_toml","text":"<pre><code>_get_updated_pyproject_toml(\n    data: str,\n    ignore: collections.abc.Iterable[str] = (),\n    all_extra_name: str = \"\",\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = (),\n) -&gt; str\n</code></pre> <p>Return the contents of a pyproject.toml file, updated to reflect the currently installed project versions, excluding those specified in <code>ignore</code>.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str</code>)           \u2013            <p>The contents of a pyproject.toml file</p> </li> <li> <code>ignore</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more project names to leave as-is</p> </li> <li> <code>all_extra_name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>An (optional) extra name which will consolidate requirements from all other extras</p> </li> <li> <code>include_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>A tuple of JSON pointers indicating elements to include (defaults to all elements).</p> </li> <li> <code>exclude_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>A tuple of JSON pointers indicating elements to exclude (defaults to no exclusions).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The contents of the updated pyproject.toml file.</p> </li> </ul> Source code in <code>src/dependence/update.py</code> <pre><code>def _get_updated_pyproject_toml(\n    data: str,\n    ignore: Iterable[str] = (),\n    all_extra_name: str = \"\",\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = (),\n) -&gt; str:\n    \"\"\"\n    Return the contents of a *pyproject.toml* file, updated to reflect the\n    currently installed project versions, excluding those specified in\n    `ignore`.\n\n    Parameters:\n        data: The contents of a *pyproject.toml* file\n        ignore: One or more project names to leave as-is\n        all_extra_name: An (optional) extra name which will\n            consolidate requirements from all other extras\n        include_pointers: A tuple of JSON pointers indicating elements to\n            include (defaults to all elements).\n        exclude_pointers: A tuple of JSON pointers indicating elements to\n            exclude (defaults to no exclusions).\n\n    Returns:\n        The contents of the updated pyproject.toml file.\n    \"\"\"\n    # Parse pyproject.toml\n    original_pyproject: dict[str, Any] = tomli.loads(data)\n    updated_pyproject: dict[str, Any] = deepcopy(original_pyproject)\n    # Find and update requirements\n    _update_document_requirements(\n        updated_pyproject,\n        ignore=ignore,\n        include_pointers=include_pointers,\n        exclude_pointers=exclude_pointers,\n    )\n    # Update consolidated optional requirements\n    project_optional_dependencies: dict[str, list[str]] = (\n        updated_pyproject.get(\"project\", {}).get(\"optional-dependencies\", {})\n    )\n    # Update an extra indicated to encompass all other extras\n    if project_optional_dependencies and all_extra_name:\n        key: str\n        dependencies: list[str]\n        project_optional_dependencies[all_extra_name] = list(\n            iter_distinct(\n                chain(\n                    *(\n                        dependencies\n                        for key, dependencies in (\n                            project_optional_dependencies.items()\n                        )\n                        if key != all_extra_name\n                    )\n                )\n            )\n        )\n    # Only dump the data if something was updated\n    if original_pyproject != updated_pyproject:\n        return tomli_w.dumps(updated_pyproject)\n    return data\n</code></pre>"},{"location":"api/update/#dependence.update._get_updated_toml","title":"_get_updated_toml","text":"<pre><code>_get_updated_toml(\n    data: str,\n    ignore: collections.abc.Iterable[str] = (),\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = (),\n) -&gt; str\n</code></pre> <p>Return the contents of a TOML file, updated to reflect the currently installed project versions, excluding those specified in <code>ignore</code>.</p> <p>Note: This functions identically to <code>get_updated_pyproject_toml</code>, but does not consolidate optional dependencies.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str</code>)           \u2013            <p>The contents of a TOML file</p> </li> <li> <code>ignore</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more package names to leave as-is</p> </li> <li> <code>include_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>A tuple of JSON pointers indicating elements to include (defaults to all elements).</p> </li> <li> <code>exclude_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>A tuple of JSON pointers indicating elements to exclude (defaults to no exclusions).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The contents of the updated TOML file.</p> </li> </ul> Source code in <code>src/dependence/update.py</code> <pre><code>def _get_updated_toml(\n    data: str,\n    ignore: Iterable[str] = (),\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = (),\n) -&gt; str:\n    \"\"\"\n    Return the contents of a TOML file, updated to reflect the\n    currently installed project versions, excluding those specified in\n    `ignore`.\n\n    Note: This functions identically to `get_updated_pyproject_toml`, but\n    does not consolidate optional dependencies.\n\n    Parameters:\n        data: The contents of a TOML file\n        ignore: One or more package names to leave as-is\n        include_pointers: A tuple of JSON pointers indicating elements to\n            include (defaults to all elements).\n        exclude_pointers: A tuple of JSON pointers indicating elements to\n            exclude (defaults to no exclusions).\n\n    Returns:\n        The contents of the updated TOML file.\n    \"\"\"\n    # Parse pyproject.toml\n    original_pyproject: dict[str, Any] = tomli.loads(data)\n    updated_pyproject: dict[str, Any] = deepcopy(original_pyproject)\n    # Find and update requirements\n    _update_document_requirements(\n        updated_pyproject,\n        ignore=ignore,\n        include_pointers=include_pointers,\n        exclude_pointers=exclude_pointers,\n    )\n    # Only dump the data if something was updated\n    if original_pyproject != updated_pyproject:\n        return tomli_w.dumps(updated_pyproject)\n    return data\n</code></pre>"},{"location":"api/update/#dependence.update.update","title":"update","text":"<pre><code>update(\n    paths: collections.abc.Iterable[str],\n    ignore: collections.abc.Iterable[str] = (),\n    all_extra_name: str = \"\",\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = (),\n) -&gt; None\n</code></pre> <p>Update requirement versions in the specified files.</p> <p>Parameters:</p> <ul> <li> <code>path</code>           \u2013            <p>One or more local paths to a setup.cfg, setup.cfg, and/or requirements.txt files</p> </li> <li> <code>ignore</code>               (<code>collections.abc.Iterable[str]</code>, default:                   <code>()</code> )           \u2013            <p>One or more project names to ignore (leave as-is)</p> </li> <li> <code>all_extra_name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>If provided, an extra which consolidates the requirements for all other extras will be added/updated to setup.cfg or setup.cfg (this argument is ignored for requirements.txt files)</p> </li> <li> <code>include_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>A tuple of JSON pointers indicating elements to include (defaults to all elements).</p> </li> <li> <code>exclude_pointers</code>               (<code>tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>A tuple of JSON pointers indicating elements to exclude (defaults to no exclusions).</p> </li> </ul> Source code in <code>src/dependence/update.py</code> <pre><code>def update(\n    paths: Iterable[str],\n    ignore: Iterable[str] = (),\n    all_extra_name: str = \"\",\n    include_pointers: tuple[str, ...] = (),\n    exclude_pointers: tuple[str, ...] = (),\n) -&gt; None:\n    \"\"\"\n    Update requirement versions in the specified files.\n\n    Parameters:\n        path: One or more local paths to a setup.cfg,\n            setup.cfg, and/or requirements.txt files\n        ignore: One or more project names to ignore (leave as-is)\n        all_extra_name: If provided, an extra which consolidates\n            the requirements for all other extras will be added/updated to\n            setup.cfg or setup.cfg (this argument is ignored for\n            requirements.txt files)\n        include_pointers: A tuple of JSON pointers indicating elements to\n            include (defaults to all elements).\n        exclude_pointers: A tuple of JSON pointers indicating elements to\n            exclude (defaults to no exclusions).\n    \"\"\"\n    if isinstance(paths, str):\n        paths = (paths,)\n\n    def update_(path: str) -&gt; None:\n        _update(\n            path,\n            ignore=ignore,\n            all_extra_name=all_extra_name,\n            include_pointers=include_pointers,\n            exclude_pointers=exclude_pointers,\n        )\n\n    deque(map(update_, paths), maxlen=0)\n</code></pre>"}]}